---
layout: post
title: "DB topics - Recovery"
---

### [ARIES] (http://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics)
ARIES is complex because it combines no force and steal
#### Buffer manager
1. force or no force? (when XACT commits, do you write its dirty pages to disk?)
    * force: write dirty pages to disk (simple, slow)
        * it avoids the need to REDO on restart
- steal or no steal? (can you evict a dirty page from a running XACT?)
    * no steal: you can not deprive dirty page from a running XACT (simple, slow)
    * steal: write uncommitted page into disk
        * it needs UNDO to correct the data in the disk

#### Basic idea1: Write Ahead Log(WAL)
no force on flushing the page rather than force flushing the log records

* every data update generate a log record with enough information to Redo or Undo the update
* before stealing a page, make sure all log records for updates to the page are on disk
* before a XACT commits, flush all its log records to disk
* after XACT commits, write commit log


#### 3 phases of recovery

* **commit != write to disk && uncommitted != not write to disk**
* REDO is fixing that some XACTs have committed, but they do not exist on the disk
* UNDO is fixing that some XACTs have not committed, but they have been written to the disk

------start of oldest "failed" XACT--------"firstLSN"----------most recent CKP--------end of log

start of oldest "failed" XACT, "firstLSN"(DPT), most recent CKP could be **arbitrary order**

1. analysis
    * determine starting point for Redo
    * identify set of "might have been dirty at crash" pages
    * identify "loser" XACTs (which did not make it at commit point)
    * scans log forward from most recent CheckPoint
        * initialize XACT table & DPT to values in CheckPoint (Recover from CPT state)
        * process log records
            * adding/deleting XACTs as they come and go (remove XACT from TT if XACT commited)
            * add entries to the DPT for additional pages being updated (update DPT)
                * we add all these pages because ARIES does not log whether a page is dirty, so the DPT is now a super set
            * "firstLSN" = earliest recovery_LSN in DPT, is place to begin REDO pass
                * recovery_LSN could be before CKP (arbitrary order)
- redo: bring the crashed system to normal (what it wanted to do)
    * scans log forward from firstLSN
    * for each log record, redo operation
        1. apply logged update to the page it applies to
        - set pageLSN of the page to that of the log record
- undo: undo the failed transaction
    * scan backwards from end of log, undoing updates of uncommited transactions
    * To apply an undo
        * apply undo from log record
        * write a CLR (compensation log record) with:
            * undo information (what was done)
            * undoNextLSN = LSN of next older log record that must be undone for XACT
        * When CLRs are encountered during REDO, redo the undo log
        * When CLRs are encountered during UNDO, ignore, follow undoNextLSN to find next log record to undo
            * so the CLR is bounded
        * "nested top action": something that should not be undone(dangerous), even if XACT fails
            * skip them


#### key data structure
1. XACT table
    * entries for each active XACT, keeps LogSequenceNumber(LSN) of last log record generated by XACT (last LSN)
    * LSN tells you whether it is within the log
- Dirty Page Table (DPT)
    * entries for all dirty buffer-resident pages; entries contain a **recovery_LSN** field
        * **recovery_LSN**: the LSN of log record that first dirtied the page

#### Checkpoint records
* do not have to go beyond certain point (rather than go back from the very start)
* it is written periodically
* save current XACT table, DPT

Think Cases: start_before_CKP/start_after_CKP & finish_before_crash/not_yet_finished


### [2 Phase Commit] (http://en.wikipedia.org/wiki/Two-phase_commit_protocol)
[Message flow] (http://en.wikipedia.org/wiki/Two-phase_commit_protocol#Message_flow)

* force: the same term in ARIES means flush to disk

#### Normal 2PC
There is no default answer in this protocol, since it forces all the logs, the subordinate and coordinator know what is the status of transaction

It would lost memory about the transaction when the coordinator logs "end"
##### handling coordinator failure
* case1: before forcing commit/abort -> XACT is aborted
* case2: after forcing commit/abort -> recovery process drives to commit/abort

##### subordinate fails
* before forcing prepare/abort -> outcome is abort
* after forcing abort(means vote no) -> outcome is abort
* after forcing prepare(means vote yes) -> contact coordinator
* after forcing commit/abort -> commit or abort (send a ACK)
    * coordinator may forget about the XACT, so it would ignore

#### Read-only
1. coordinator "prepare"
- read-only subordinate write no log record, vote "read"
- coordinator ignores read-only sites during 2nd phase

#### Presumed-abort 2PC
default reply is abort when it has no memory about it
##### abort case
1. coordinator "prepare"
- subordinate abort, no force, since not neccessary
- coordinator abort, no force, if it fails, it would just recover with abort
- other subordinate abort, no force, since coordinator default answer is abort

##### commit case
1. coordinator "prepare"
- subordinate prepare, force, since it records the start
- coordinator commit, force
- other subordinate commit, force, since coordinator may finish the transaction and forget about it, then it would say abort

#### Presumed-commit
default reply is commit when it has no memory about it
##### abort case
1. coordinator "collect", "prepare", force
    * collect is the **begin** log log all participants, when coordinator recovers, it would not know the transaction and answer "commit"
- subordinate abort, force
- coordinator abort, force
- subordinate abort, force

##### commit case
1. coordinator "collect", "prepare", force
    * collect is the **begin** log log all participants, since if there is no such log, when coordinator recovers, it would not know the transaction and answer "commit"
- subordinate prepare, force
- coordinator commit, force, since it indicates whether this transaction passes this phase
    * TODO
- subordinate commit, no force, since the default answer is "commit"

### Buffer management
#### Query Locality Set Model (QLSM)
* sequential patterns
    * straight sequential (file scan)
        * need one page
        * replace with next one
    * clustered sequential
        * example: like inner relation in merge join (seq + backup)
        * number of pages in largest cluster
        * LRU (kick out the oldest)

##### Love/Hate hints
Love: I would expect to come back; Hate: I would rather not see them again

2 LRU chains, 1 love chain, 1 hate chain

##### [LRU-k (Least Recent Used)] (http://en.wikipedia.org/wiki/Page_replacement_algorithm#Variants_on_LRU)
LRU-2: pick the next most recent pages among Pi; LRU-k: pick the kth most recent pages among Pi




### Summary
* The difference between locking records, latching data structures and pinning pages in DBMS
    * latching is like semaphore, physical lock
    * locking provides multi granularity, logical lock
    * TODO

#### ARIES
* What is "redo", and why needs it?
    * redo to what actually happened, not just successful transactions. This allows for CLR during recovery and helps with enabling logical redo/undo
* How about do no logging during UNDO?
    * There maybe subsequent crash, system would not know how many UNDOs have been performed
* How about writing normal log instead of CLR?
    * If repeated crashes happend, the log space will become unbound
* How ARIES uses bounded space for recovery even in repeated crashes?
    * ARIES writes only and at most one log record per undo (due to the use of CLRs) during UNDO phase, so the space is bounded
* Two conditions that there is no need to redo an update to a data page without even examining the page in question
    1. the page is not in DPT
    - the recovery_LSN in DPT of this page > LogRecLSN (if logRecLSN <= pageLSN at affected page)
        * this is for efficiency, not neccessary
* Why not writes any log during REDO phase?
    * because previous log has recorded what have been done, log for REDO phase would just be duplicated
* How transactions could be ignored during recovery without causing a problem?
    * Some transactions start before crash but write no log records into disk
* Does the pageLSN of a page modified during the REDO phase need to be updated to account for this modification? Why or why not?
    * Yes. If not, there is no record of whether or not the REDO has been performed, which can lead to errors if there are subsequent crashes.

#### 2PC
* What if coordinator fails before make commit/abort decision? Does it need to force log a "begin" log?
    * In presume abort, we do not need force "begin" log, coordinator just abort in default
* Why it is OK to not force end record of coordinator?
    * if end record is flushed before coordinator crash, everything is fine
    * if end record is not flushed before crashing, coordinator would recovery and find out it has instructed commit/abort so it would resend "commit/abort" message to ensure all subordinate know
* Any impact on turning on force end record?
    * During normal operation, it would slow down, since it would have extra flushes into disk
    * During recovery operation, it would speed up, since it would skip resend the commit/abort message
* Why 2PC is a blocking protocol, how can a participant get blocked by others?
    * If the participant vote YES and the coordinator crashes, the participant has to be blocked until it recovers
* Why "collecting" record is required in presumed-commit 2PC but not in presumed-commit 2PC?
* In "read-only" optimization, if a subordinate is read-only, then why can’t the coordinator just ignore it during the commit protocol, because it really doesn’t matter whether the read-only subordinate commits or not
    * the coordinator may not know ahead of time which subordinate is read-only
    * the subordinate may not know if it is read-only, since they could have a unsatisfied conditional update so that there would be no update
