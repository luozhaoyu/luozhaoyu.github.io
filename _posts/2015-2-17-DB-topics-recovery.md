---
layout: post
title: "DB topics - Recovery"
---

### Recovery
[ARIES] (http://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics)
#### Buffer manager
1. force or no force? (when XACT commits, do you write its dirty pages to disk?)
    * force: write dirty pages to disk (simple, slow)
- steal or no steal? (can you evict a dirty page from a running XACT?)
    * no steal: you can not deprive dirty page from a running XACT (simple, slow)

#### Basic idea1: Write Ahead Log(WAL)
no force on flushing the page rather than force flushing the log records

* every data update generate a log record with enough information to Redo or Undo the update
* before stealing a page, make sure all log records for updates to the page are on disk
* before a XACT commits, flush all its log records to disk
* after XACT commits, write commit log


#### 3 phases of recovery
1. analysis
- redo: bring the crashed system to normal (what it wanted to do)
- undo: undo the failed transaction

#### key data structure
1. XACT table
    * entries for each active XACT, keeps LogSequenceNumber(LSN) of last log record generated by XACT (last LSN)
    * LSN tells you whether it is within the log
- Dirty Page Table (DPT)
    * entries for all dirty buffer-resident pages; entries contain a **recovery_LSN** field
        * **recovery_LSN**: the LSN of log record that first dirtied the page

#### Checkpoint records
* do not have to go beyond certain point (rather than go back from the very start)
* it is written periodically
* XACT table, DPT

### Summary
* The difference between locking records, latching data structures and pinning pages in DBMS

#### ARIES
* What is "redo", and why needs it?
    * redo to what actually happened, not just successful transactions. This allows for CLR during recovery and helps with enabling logical redo/undo
* How about do no logging during UNDO?
    * There maybe subsequent crash, system would not know how many UNDOs have been performed
* How about writing normal log instead of CLR?
    * If repeated crashes happend, the log space will become unbound
* How ARIES uses bounded space for recovery even in repeated crashes?
    * ARIES writes only and at most one log record per undo (due to the use of CLRs) during UNDO phase, so the space is bounded
* Two conditions that there is no need to redo an update to a data page without even examining the page in question
    1. the page is not in DPT
    - the recoveryLST in DPT of this page > LogRecLSN
* Why not writes any log during REDO phase?
* How transactions could be ignored during recovery without causing a problem?
    * Some transactions start before crash but write no log records into disk
* Does the pageLSN of a page modified during the REDO phase need to be updated to account for this modification? Why or why not?
    * Yes. If not, there is no record of whether or not the REDO has been performed, which can lead to errors if there are subsequent crashes.
